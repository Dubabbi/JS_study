# 1. 프로그래밍

### 1. 프로그래밍 언어
 - 컴퓨터가 이해할 수 있는 언어(기계어)
 - 기계어로 직접 명령을 전달하는 것을 대신할 가장 유용한 대안은 사람이 이해할 수 있는 약속된 구문으로 구성된 "프로그래밍 언어"를 사용해 프로그램을 작성한뒤 컴퓨터가 이해 할수 있는 기계어로 변환히는 일조의 번역기를 이용하는것이다. (일종의 번역기를 컴파일러 또는 인터프리터라고 한다.)

# 2. 자바스크립트란
 
### 1. 소개
 - 1995년 약 90%의 점유율로 웹 브라우저 시장을 지배하고 있던 넷스케이프 커뮤니케이션즈는 웹페이지의 보조적인 기능을 수행하기 위해 브라우저에서 동작하는 경량 프로그래밍을 도입하기로 한다. 이게 브렌던 아이크가 개발한 자바스크립트.

### 2. 표준화
 - 1996년 8월 MS에서 JScript를 인터넷 익스플로러 3.0에 탑재
 - MS와 넷스케이프 커뮤니케이션즈가 경쟁적으로 자사 브라우저 시장 점유율을 높이기 위해 자사 브라우저에서만 동작하는 기능을 추가
   => 크로스 브라우징 이슈발생
 - 자바스크립트의 파편화를 방지하고 모든 브라우저에서 동작하는 사양서가 필요
 - 넷스케이프 커뮤니케이션즈는 컴퓨터 시스템의 표준을 관리하는 비영리 표준화 기구인 ECMA 인터내셔널에 자바스크립트의 표준화를 요청
 - 1997년 7월 ECMA-262라고 불리는 표준화된 자바스크립트 초반 시양이 완성
 - 각 브라우저 제조사는 ECMA Script 사양을 준수해서 브라우저에 내장된 자바스크립트 엔진을 구현을 해야됨. 
   <a href="https://ko.wikipedia.org/wiki/ECMA%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8">Ecma script wiki </a>
### 3. 성장, 역사
 - 초기에는 웹페이지의 보조적인 기능을 수행하기 위해 한정적인 용도로 사용
 - 대부분의 로직은 웹 서버에서 실행되고, 브라우저는 서버로부터 HTML과 CSS를 단순히 랜더링 함.
    #### 3-1 Ajax
   - 1999년 자바스크립트를 이용해 서버와 브라우저가 비동기 방식으로 데이터를 교환할 수 있는 통신기능인 Ajax가 XMLHttpRequest라는 이름으로 등장
   - 이전까지는 화면이 전환되면 서버로부터 새로운 HTML을 받아 웹페이지 전체를 랜더링 하였고, 이로인해 변경할 필요가 없는 부분까지 처음부터 다시 랜더링되어야 했기 때문에 성능면에서도 불리하였다.
   - 또 화면깜박임 현상도 있어 사용자 경험에도 좋지 않았다.
   - Ajax의 등장으로 웹페이지의 변경할 필요가 없는 부분은 다시 랜더링 하지 않고 서버로부터 필요한 데이터만 전송받아 변경해야 하는 부분만 한정적으로 랜더링 가능해졌다.
     <a href="https://developer-talk.tistory.com/842">XMLHttpRequest 사용법</a>

   #### 3-2 JQuery
   - 다소 번거로운 DOM을 쉽게 제어할 수 있고, 크로스 브라우징 이슈도 어느정도 해결
 
   #### 3-3 V8 자바스크립트 엔진
   - 자바스크립트로 웹 어플리케이션 구축하려는 시도가 늘면서 더욱 빠르게 동작하는 자바스크립트으 엔진의 필요성이 대두되면서 2008년 V8 자바스크립트 엔진이 등장.
   - V8 자바스크립트 엔진으로 촉발된 자바스크립트의 발전으로 과거 웹 서버에서 수행되던 로직들이 대거 클라이언트로 이동.
   #### 3-4 Node.js
   - 구글 V8 자바스크립트 엔진으로 빌드된 자바스크립틍 런타임환경
   - 자바스크립트를 브라우저 이외의 환경에서도 동잘 할 수 있도록 자바스크립트 엔진을 브라우저에서 독립시킨 자바스크립트 실행 환경이다.
   - 서버 사이드 애플리케이션 개발에 주로 사용 됨.
  #### 3-5 특징
   - 자바스크립트는 HTML, CSS와 함께 웹을 구성하는 요소 중 하나로 웹 브라우저에서 동작하는 유일한 프로그래밍 언어
   - 자바스크립트는 별도의 컴파일 작업 수행하지 않는 인터프리터 언어 대부분의 자바스크립트 엔진은 인터프린터와 컴파일러의 장점을 결합해 비교적 차리속도가 느린 인터프리터의 단점을 해결했다.
   - 인터프리터는 소스코드를 즉시 실행하고 컴파일러는 빠르게 동작하는 머신코드를 생성하고 최적화한다. 컴파일 단계에서 추가적인 시간이 필요함에도 더욱 빠르게 코드를 실행할 수 있다.


# 4. 변수
 - 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 메모리 공간을 식별하기 위해 붙이 이름
 - 메모리 공간에 저장된 값을 식별 할 수 있는 고유한 이름을 변수 이름 이라 한다. 
 - 변수에 값을 지정하는 것을 할당이라하고 변수에 저장된 값을 읽어드리는것을 참조라고 함.
 - 변수이름은 사람을 위해 사람이 이해 할수 있는 언어로 값이 저장된 메모리 공간에 붙인 상징적인 이름.

   ### 4-1 식별자
     - 식별자는 어떤 값을 구별해서 식별 할 수 있는 고유한 이름.
     - 식별자는 값이 아니라 메모리 주소를 기억하고 있음.
     - 메모리주소를 통해 메모리 공간에 저장된 값에 접근 할 수 있다.
   
   ### 4-2 변수선언
     - 변수 선언은 변수를 생성하는것을 말하며, 값을 저장하기 위한 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수 있게 함.
     - 변수를 사용할려면 반드시 선언이 필요, 변수를 선언할때는 var, let, const 키워드를 사용.
     - ES6이전에는 var를 사용해서 변수를 선언함.
     - var키워드는 선어과 초기화 단계를 동시에 진행 => 초기화 단계를 거치치 않으면 확보된 메모리 공간에는 이전에 다른 애플리케이션이 사용했던 값이 남아 있을수도 있다.
   
   ### 4.3 변수선언의 실행 시점과 호이스팅
     - 변수선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점, 런타임이 아니라 그이전에서 먼저 실행됨.
     - 소스코드의 평가과정을 거치면서 소스코드를 실행하기 위한 준비를 하고 소스코드 평가과정에서 자바스크립트 엔진은 변수 선언을 포함한 모든 선언문을 소스코드에서 찾아내 먼저 실행 한다.
     - 자바스크립트 엔진은 변수 선언이 소스코드의 어디에 있든 상관없이 다른 코드보다 먼저 실행
     - 변수 선언문이 코드의 코드의 선두로 끌어 올려진 것처럼 동작하는것을 호이스팅이라고 한다.
   
   ### 4.4 값의 할당
     ```js
      var score; // 변수 선언
      score = 80; // 값을 할당
      var score = 80; // 변수 선언고 할당
    ```
    변수 선언과 값의 할당을 2개의 문으로 나누어 표현한 코드와 변수 선언과 값의 할당을 하나의 문으로 단축 표현한 코드는 정확히 동일하게 동작. 변수 선언은 소스코드가 순자적으로 실행되는 시점인 런타임 이전에 먼저 실행되지만 값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행.
      ```js
      console.log(score) // undefined
      var score // 변수 선언
      score = 80; // 값을 할당
      console.log(score); // 80
   
      // 문제)
      console.log(score) 
      score = 80;
      var score;
      console.log(score);
    ```
   
   ### 4.5 값의 재 할당
     - var 키워드로 선언한 변수는 값을 재할당할 수 있다. 재할당은 현재 변수에 저장된 값을 버리고 새로운값을 저장하는것이다.
   
   ### 4-6 식별자 네이밍 규칙
     - 식별자는 특수문자를 제외한 문자, 숫자, 언더스코어, 달러 기호를 포함할 수있다.
     - 예약어는 사용할 수 없다.
     - 숫자로 시작하는것은 허용되지 않는다. (var 2data = 'data' (x));
     - 대소문자를 구별함.
     - 가독성을 위해 변수의 존재 목적을 쉽게 이해할 수 있도록 의미를 명확히 표현해야한다.
     ```js
     var x = 3;
     var score = 3; 
     
     var lastName; // 카멜 케이스
     var last_name; // 스네이크 케이스
     var LastName; // 파스칼 케이스
     
     // 헝가리언 케이스
     var strFirsetName; // 타입 + 식별자
     var $ele; // DOM 노드
     var observable$; // RxJS 옵저버블
    ```

    